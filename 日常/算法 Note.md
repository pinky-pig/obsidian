
### **时间复杂度和空间复杂度**

复杂度的计算：
时间复杂度 -> 每行代码运行次数之和 -> 取最大数量级的
空间复杂度 -> 每个变量占用的空间 -> 取最大数量级的

时间复杂度就是运行了多少次，运行一次是 O(1)，运行 n 次是 O(n) ， 运行 n^2 次就是 O(n^2) 。
空间复杂度就是这里面的，占用最大内存的变量。
比如有个for循环(traverse)，先看每个占用多少内存，然后发现占用最大的是 arr ，而且整个函数的内存占用也不会变，那么空间复杂度是O(1)。那第二个for循环(init)，是会随着n变的，n多大，arr多大，那么占用空间也会多大，那么空间复杂度是 O(n)
```js
function traverse(arr) {
    var len = arr.length
    for(var i=0;i<len;i++) {
        console.log(arr[i])
    }
}
function init(n) {
    var arr = []
    for(var i=0;i<n;i++) {
        arr[i] = i
    }
    return arr
}

```

### **数组**

[ 'push', 'pop', 'shift', 'unshift' ]

### **栈**

先进后出

### **队列**

先进先出

### **链表**

访问时间复杂度O(n)， 增删时间复杂度O(1)。

```js
const list = {
    // 数据域
    val: 1,
    // 指针域，指向下一个结点
    next: {
        val:2,
        next: {
	        val: 3,
	        next: {}
        }
    }
}   

```

其实从上面这个代码可以看出，第一个节点 ``{val: 1,next: {}}``，第二个节点 ``{val: 2,next: {}}``。要想访问第二个节点，肯定要通过第一个节点，这样访问 `list.next.val`。
这也是链表的特性，访问要从头部开始访问。
而删除，如果要删除 第二个节点，那么知道第一个节点的话，只需要将第一个节点的 next 指向第三个节点就好。如果不知道第一个节点，那么就需要从头开始找到要删除的目标节点的先驱节点，再将先驱节点的 next 指向目标节点的 next 就好了，要删除的目标节点没有引用的话，就会被垃圾回收。

访问的时间复杂度，从头开始，最好的情况，第一个就是要找的，那么时间复杂度是 O(1)。
最差的情况，最后一个才是要找的，那么时间复杂度O(n)，时间复杂度自然要取最坏的情况，最大的O(n)。

增删的时间复杂度，如果知道先驱节点，那么直接改其next 就好了，时间复杂度为 O(1)。
如果不知道，那么就需要先访问找到，再改其 next ，那么这里时间复杂度是 O(n) + O(1)。
不过针对于增删来说，时间复杂度是O(1)，因为“先访问找到”这一步不属于增删，而是先访问，再增删。

总之，访问链表的时间复杂度是 O(n) ，增删的时间复杂度是 O(1)

### **二叉树**

```js
const root = {
  val: "A",
  left: {
    val: "B",
    left: {
      val: "D"
    },
    right: {
      val: "E"
    }
  },
  right: {
    val: "C",
    right: {
      val: "F"
    }
  }
};
```

看 根 的位置，哪个位置就是那种遍历

- 前序遍历 -> 根左右
- 中序遍历 -> 左根右
- 后序遍历 -> 左右根

```js
// 所有遍历函数的入参都是树的根结点对象
function preorder(root) {
    // 递归边界，root 为空
    if(!root) {
        return 
    }
     
    // 输出当前遍历的结点值 
    // 根左右 左根右 左右根 在哪里就是那种遍历
    // console.log('当前遍历的结点值是：', root.val)  
    // 递归遍历左子树 
    preorder(root.left)  
    // 递归遍历右子树  
    preorder(root.right)
}
```