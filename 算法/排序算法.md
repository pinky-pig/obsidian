[[#1. 冒泡排序]]
[[#2. 插入排序]]
[[#3. 选择排序]]
[[#4. 快速排序]]
[[#5. 归并排序]]
[[#6. 希尔排序]]
[[#7. 堆排序]]
[[#8. 计数排序]]
[[#9. 桶排序]]
[[#10. 基数排序]]



比较类排序： 元素两两相互比较，大的放后面，小的放前面，复杂度上限 O(n logn)
非比较类排序：不需要两两比较，复杂度上限 O(n)

排序
├─ 比较类排序 
│   ├─ 交换
│        ├─ **冒泡**
│        └─ **快速**
│   ├─ 插入
│        ├─ **简单插入**
│        └─ **希尔**
│   ├─ 选择
│        ├─ **简单选择**
│        └─ **堆**
│   └─ 归并
│        ├─ **二路归并**
│        └─ **多路归并**
└─ 非比较类排序
    ├─ **计数排序**
    ├─ **桶排序**
	└─ **基数排序**

## 1. 冒泡排序

一个泡一个泡的往上涌，最终排序。

## 2. 插入排序

打牌的时候，新摸一张牌，然后插入手中就是这样插入的。

![[插入排序.png]]
## 3. 选择排序

打牌的时候，同花顺最大，每个人抽 5 张牌到自己手里，你开了透视，**选择** 10 J Q K A ，到自己手里。

![[算法/图片/选择排序.png]]

## 4. 快速排序

“给我一个支点，我能翘起整个地球。”
先有个支点 pivot ，然后分成两块，“天才向左，魔鬼向右”。然后两边的继续这样，直到尽头。

## 5. 归并排序

写代码的时候，总是会遇到合代码，Merge Code 。这里的归并，就是合并，就是 Merge sort 。  

一副牌，分给四个人，四个人拿到手里，按个顺序（从小到大）理好牌。两人一组，分成两组，组内对战。每人先拿一张牌，比大小，谁的小（或者大）谁输，输的人将那一张牌，放到牌桌。重新下一张牌跟赢家比，赢家还是那张牌，比大小，输的输掉那张牌，放到第一次输的牌下，游戏直到一个人没牌，赢家取胜，手中的牌全部放到牌桌。两个赢家拿着刚才牌桌上的牌，继续游戏，直到最后获胜。

整个流程就是归并了，记忆关键词，归并 Merge -> 合并代码 -> 代码中有分支 -> “分治” -> 分就是发牌 -> 治就是合牌。

![[归并排序.png]]
## 6. 希尔排序

**插入排序是一个一个的比较插入，在大数据量的时候比较费事，于是让它一下子横跨多个比较，就是希尔排序。**

因为有个人叫做 “唐纳德·希尔（Donald Shell）”，所以叫做*希尔排序*。

希尔排序就是使用的插入排序，不过多做了一些操作，而这些操作增加了一些比较，目的是为了减少一些交换。主要是插入排序的步长太短，一个一个比较，增大一下步长，一下移动的远。

不管前面有多少操作，后面最终一步都是插入排序。当然这些操作有一些比较交换，所以其实希尔排序去掉前面一些操作，就是插入排序。而前面的那些操作，提高了效率，那么就算是插入排序 Pro 版本。

举例：
比如有体育课上，老师站在操场台子上（居高临下看的不是很清，这就需要靠同学们了），要给全班同学（20名同学，我们是小班教学）按身高排队，。

怎么排呢？先找出一个，然后后面每一位同学跟他比较，矮的站后面，高的站前面。然后再找一个，先跟最高的比，然后再跟后面的同学比，直到找到位置。这种方法当然可以，但是假如刚开始找的同学差不多190 ，然后排队，排了10几名同学了，最矮的是差不多 170 ，这个时候来了个 160 的（身高很自信），然后从190开始比，然后一个一个比，交换位置，直到排到最后。这中间那么多次比较说实话不太必要，直接最后就行。所以这种比较比较累一点。

现在有这种方法，所有人站成一排，报号。依次进行下面操作：
1.  首先从第 1 位同学开始，每 5 个人出列，也就是第 1 ，6 ，11 ，16 位四位同学，向前一步走。
2. 然后这四个比较身高，换位置。高的同学右边站，矮的左边站，站到原来的那名同学的位置。从左到右，从低到高的换完之后，向后一步走，入列。
3. 然后从第 2 位同学开始，还是每 5 个人出列，也就是第 2 7 12 18 四位同学，继续上面的操作。
4. ...
5. 然后从第 5 位同学开始，还是每 5 个人出列，也就是第 5 10 15 20 四位同学，继续上面的操作。
以上就是第一轮操作，每次操作，会将 4 个中高的都往右排，低的往左排了。  
但是还有可能是本来的相邻的几个同学，高矮还没比较。就是比如：比的是第 1 ，6 ，11 ，16 ，这个结果是从左到右好了，但是原来的 1 , 2 , 3 , 4 , 5 同学的身高没比。  
所以第一轮结果肯定是参差不齐的，但是有了个趋势了。

接下来就是第二次重新开始比较了：
1. 还是从第 1 位同学开始，每 3 个人出列，也就是第 1 ，4 ，7，10，13, 16, 19 位七位同学比较，高矮排序。
2. ...
3. 从第 3 位同学开始，每 3 个人出列，也就是第 3 ，6 ，9，12，15, 18 位六位同学比较，高矮排序。
这个时候，肯定还是有两两之间没有比过的元素，但是现在全部同学，分成了三组比较，在这每三组内，顺序肯定是从左到右从矮到低排列好的。

接下来就是第三次重新开始比较了，每两位同学...

最后第四次重新开始比较，每一位同学，就是单个同学开始，插入排序，一个个比较，找位置。

综上会发现，其实第四次是插入排序，没有前面三次，最后一次也是能正确排序的。而前面的那些操作，就是将移动交换的位置大一些，首先是平均分组的，其次是步长由大到小，也是足够长，这样每组元素交换后的位置，即使位置不对，但也是在那个步长范围内。后续的交换也是比较小的交换，避免出现一个最小元素从最大的元素一一比较到最后的位置。

插入排序，每次移动的是 1 , 过一遍元素比较就好了，就是元素要一个一个过。
希尔排序，每次移动的要很远，移动的位置就很快，即使位置不对，下次移动回正也是跟随步长，交换次数没有那么多。

不过也不绝对，通常情况下，希尔排序的效率要高于普通的插入排序，因为它通过比较距离较远的元素来进行交换，可以更快地将较小的元素移动到正确的位置。但是，希尔排序的性能依赖于所选取的增量序列，不同的增量序列可能导致不同的性能表现。

在一般情况下，希尔排序的平均时间复杂度约为 O(n^1.3)，而插入排序的平均时间复杂度为 O(n^2)。因此，对于大型数据集，希尔排序通常比插入排序更快。

但在某些情况下，插入排序可能效率更高，尤其是当数组已经部分有序时，插入排序的效率会非常高，因为它只需要很少的交换操作。而希尔排序可能需要多次迭代才能逐渐将数组调整为有序状态。

## 7. 堆排序

是一个**完全二叉树**，不是一个排序二叉树（子节点之间没有排序关系）。

## 8. 计数排序
## 9. 桶排序
## 10. 基数排序
 
