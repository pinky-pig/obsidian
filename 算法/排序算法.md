1. 冒泡排序
2. 插入排序
3. 选择排序
4. 快速排序
5. 归并排序
6. 希尔排序
7. 堆排序
8. 计数排序
9. 桶排序
10. 基数排序

排序
├─ 比较类排序 
│   ├─ 交换
│        ├─ **冒泡**
│        └─ **快速**
│   ├─ 插入
│        ├─ **简单插入**
│        └─ **希尔**
│   ├─ 选择
│        ├─ **简单选择**
│        └─ **堆**
│   └─ 归并
│        ├─ **二路归并**
│        └─ **多路归并**
└─ 非比较类排序
    ├─ **计数排序**
    ├─ **桶排序**
	└─ **多路归并**

## 1. 冒泡排序

一个泡一个泡的往上涌，最终排序。

## 2. 插入排序

打牌的时候，新摸一张牌，然后插入手中就是这样插入的。

![[插入排序.png]]
## 3.选择排序

打牌的时候，同花顺最大，每个人抽 5 张牌到自己手里，你开了透视，**选择** 10 J Q K A ，到自己手里。

![[算法/图片/选择排序.png]]

## 4. 快速排序

“给我一个支点，我能翘起整个地球。”
先有个支点 pivot ，然后分成两块，“天才向左，魔鬼向右”。然后两边的继续这样，直到尽头。

## 5. 归并排序

写代码的时候，总是会遇到合代码，Merge Code 。这里的归并，就是合并，就是 Merge sort 。  

一副牌，分给四个人，四个人拿到手里，按个顺序（从小到大）理好牌。两人一组，分成两组，组内对战。每人先拿一张牌，比大小，谁的小（或者大）谁输，输的人将那一张牌，放到牌桌。重新下一张牌跟赢家比，赢家还是那张牌，比大小，输的输掉那张牌，放到第一次输的牌下，游戏直到一个人没牌，赢家取胜，手中的牌全部放到牌桌。两个赢家拿着刚才牌桌上的牌，继续游戏，直到最后获胜。

整个流程就是归并了，记忆关键词，归并 Merge -> 合并代码 -> 代码中有分支 -> “分治” -> 分就是发牌 -> 治就是合牌。

![[归并排序.png]]
## 6. 希尔排序

因为有个人叫做 “唐纳德·希尔（Donald Shell）”，所以叫做*希尔排序*。

希尔排序就是使用的插入排序，不过多做了一些操作，而这些操作增加了一些比较，目的是为了减少一些交换，减少了交换意味着提高了一些效率。

不管前面有多少操作，后面最终一步都是插入排序。当然这些操作有一些比较交换，所以其实希尔排序去掉前面一些操作，就是插入排序。而前面的那些操作，提高了效率，那么就算是插入排序 Pro 版本。

举例：
比如有体育课上，老师站在操场台子上（居高临下看的不是很清，这就需要靠同学们了），要给全班同学（20名同学，我们是小班教学）按身高排队，。

怎么排呢？先找出一个，然后后面每一位同学跟他比较，矮的站后面，高的站前面。然后再找一个，先跟最高的比，然后再跟后面的同学比，直到找到位置。这种方法当然可以，但是假如刚开始找的同学差不多190 ，然后排队，排了10几名同学了，最矮的是差不多 170 ，这个时候来了个 160 的（身高很自信），然后从190开始比，然后一个一个比，交换位置，直到排到最后。这中间那么多次比较说实话不太必要，直接最后就行。所以这种比较比较累一点。

现在有这种方法，所有人站成一排，报号。依次进行下面操作：
1.  首先从第 1 位同学开始，每 5 个人出列，也就是第 1 ，6 ，11 ，16 位四位同学，向前一步走。
2. 然后这四个比较身高，换位置。高的同学右边站，矮的左边站，站到原来的那名同学的位置。从左到右，从低到高的换完之后，向后一步走，入列。
3. 然后从第 2 位同学开始，还是每 5 个人出列，也就是第 2 7 12 18 四位同学，继续上面的操作。
4. ...
5. 然后从第 5 位同学开始，还是每 5 个人出列，也就是第 5 10 15 20 四位同学，继续上面的操作。
以上就是第一轮操作，每次操作，会将 4 个中高的都往右排，低的往左排了。  
但是还有可能是本来的相邻的几个同学，高矮还没比较。就是比如：比的是第 1 ，6 ，11 ，16 ，这个结果是从左到右好了，但是原来的 1 , 2 , 3 , 4 , 5 同学的身高没比。  
所以第一轮结果肯定是参差不齐的，但是有了个趋势了。

接下来就是第二次重新开始比较了：
1. 还是从第 1 位同学开始，每 3 个人出列，也就是第 1 ，4 ，7，10，13, 16, 19 位七位同学比较，高矮排序。
2. ...
3. 从第 3 位同学开始，每 3 个人出列，也就是第 3 ，6 ，9，12，15, 18 位六位同学比较，高矮排序。
这个时候，肯定还是有两两之间没有比过的元素，但是现在全部同学，分成了三组比较，在这每三组内，顺序肯定是从左到右从矮到低排列好的。

接下来就是第三次重新开始比较了，每两位同学...

最后第四次重新开始比较，每一位同学，就是单个同学开始，插入排序，一个个比较，找位置。

综上会发现，其实第四次是插入排序，没有前面三次，最后一次也是能正确排序的。而前面的那些操作，就是将移动交换的位置大一些，首先是平均分组的，其次是步长由大到小，也是足够长，这样每组元素交换后的位置，即使位置不对，但也是在那个步长范围内。后续的交换也是比较小的交换，避免出现一个最小元素从最大的元素一一比较到最后的位置。

插入排序，每次移动的是 1 , 过一遍元素比较就好了，就是元素要一个一个过。
希尔排序，每次移动的要很远，移动的位置就很快，即使位置不对，下次移动回正也是跟随步长，交换次数没有那么多。
不过也不绝对，希尔排序中使用的增量序列可能会导致一些元素在排序过程中被“跳跃”地移动到较远的位置，然后再在后续的排序步骤中逐渐移动回正确的位置。这样的操作可能会导致希尔排序的交换次数增多，尤其是在某些特定的输入情况下。

2 4 6 1 3 5.