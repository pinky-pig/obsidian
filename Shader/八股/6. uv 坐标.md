

简单理解，uv采样本质上就是用一个横向范围[0,1]和纵向范围[0,1]的直角坐标系去采样一张图，然后映射到模型表面上。

uv 坐标就是纹理坐标，范围在 [0,1] 之间，就是归一化，0 是 纹理起点（因为坐标系是右手坐标系，所以是左下角）， 1 是纹理终点（右上角）。

什么是归一化，就是无论尺寸是什么样的，512x512、1024x1024 或任意大小，都将其用 [0,1]的值表示，可以认为 uv 坐标就是个比例，不是实际像素大小。但是归一化也可以表示大小了。

既然都已经归一化了，那么范围[0,1]就是一个完整的纹理了。如果使用的 uv 坐标大于 1 了，那么一般情况就是纹理继续重复着显示。比如在 1.2 的位置显示的是 0.2 的像素了。当然这是可以配置的，有几种模式，可以repeat 也可以 mirror_repeat 或者别的，就不展开了。

Shader着色器通过各种花里胡哨的运算改变uv坐标，从而改变采样范围（内容），从而使我们看到贴图变形。
嗯……就好像我们拿望远镜观察星空，星星（贴图）当晚不会变，只有我们移动望远镜（uv坐标），我们看到的星星才会不同。
甚至，我们还可以在望远镜上装哈哈镜（shader），这样看到的星星也会不同。
或者，你可以想象你坐在火车上，窗外的风景就是贴图，窗就是uv坐标。风景不会跑，只有咱们的窗户在跟着车平移。
又或者 SVG 的视口。

所以有了 uv 变换着一个概念。


webgl 的坐标系统，是右手坐标系，x 轴正方向向右， y 轴正方向是向上的。而对于图像来说，它的 y 轴正方向是向下的，所以在 webgl 中使用图片，就需要对坐标进行转换，转换后的坐标称为**纹理坐标**，也称为 st 坐标或 uv 坐标。

就是，浏览器中的坐标系，比如 svg 和 canvas 都是 左上角为原点，往右往下是正方向。但是计算机图形学中的坐标系，是右手坐标系，原点在左下角，往右往上是正方向。

所以需要转换成一样的坐标，才能对应的上。

### UV 坐标的定义

- **U 坐标**：在纹理的水平轴上，从左到右的范围通常是从 0 到 1。
- **V 坐标**：在纹理的垂直轴上，从下到上的范围通常是从 0 到 1。

模型上每个顶点一个 uv 坐标，如果一个三角形被格栅化太多，会自动有插值。


片元着色器会使用 uv 坐标。


在 Three.js 中，顶点着色器中使用的 `projectionMatrix` 和 `modelViewMatrix` 是由 Three.js 自动传递的全局变量，你不需要手动定义它们。Three.js 会在渲染时自动将这些矩阵传递给着色器程序。

你的着色器代码可以直接使用 `projectionMatrix` 和 `modelViewMatrix`，并且这些矩阵会自动被设置为正确的值，确保你的顶点着色器能够正确地将顶点位置转换到屏幕坐标。

# Demo

在顶点着色器中定义 uv

```c
# 定义一个 out 的二维变量 uvInterpolator 
# out 意味着可以在片元着色器中使用
out vec2 uvInterpolator;

void main() {
	uvInterpolator = uv;
	# 下面一行的都是 threejs 中的固定写法了，threejs 中内置了这些变量
	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
```

片元着色器中：
```c
# 输出纯红色
gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
```

比如这里的片元着色器，定义的是纯红色。
因为每一个片元都是执行这个，所以都是同一个颜色。

```c
# 输出渐变，uvInterpolator.x => 0.0-1.0 => 左边黑右边红
gl_FragColor = vec4(uvInterpolator.x, 0.0, 0.0, 1.0);
```

这里定义的颜色，红色的那一栏是个变量，变量是根据 uvInterpolator 的 x 坐标变化。
每一个片元从左到右，uv坐标是从 0.0 到 1.0 ，就是 uvInterpolator.x 的值。传给 `gl_FragColor` ，那么其值的红色那个值也是从 0.0 到 1.0 ，颜色是从黑到红了。

同理

```c
// 3. uvInterpolator.y => 0.0-1.0 => 下边黑上边红
gl_FragColor = vec4(uvInterpolator.y, 0.0, 0.0, 1.0);
```

```c
// 5. 青红、蓝粉
gl_FragColor = vec4(uvInterpolator, 0.0, 1.0);
gl_FragColor = vec4(uvInterpolator, 1.0, 1.0);
```